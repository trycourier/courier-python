# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import os
import typing

import httpx
from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .core.request_options import RequestOptions
from .environment import CourierEnvironment
from .raw_client import AsyncRawCourier, RawCourier
from .send.types.message import Message
from .types.send_message_response import SendMessageResponse

if typing.TYPE_CHECKING:
    from .audiences.client import AsyncAudiencesClient, AudiencesClient
    from .audit_events.client import AsyncAuditEventsClient, AuditEventsClient
    from .auth_tokens.client import AsyncAuthTokensClient, AuthTokensClient
    from .automations.client import AsyncAutomationsClient, AutomationsClient
    from .brands.client import AsyncBrandsClient, BrandsClient
    from .bulk.client import AsyncBulkClient, BulkClient
    from .inbound.client import AsyncInboundClient, InboundClient
    from .lists.client import AsyncListsClient, ListsClient
    from .messages.client import AsyncMessagesClient, MessagesClient
    from .notifications.client import AsyncNotificationsClient, NotificationsClient
    from .profiles.client import AsyncProfilesClient, ProfilesClient
    from .templates.client import AsyncTemplatesClient, TemplatesClient
    from .tenants.client import AsyncTenantsClient, TenantsClient
    from .translations.client import AsyncTranslationsClient, TranslationsClient
    from .users.client import AsyncUsersClient, UsersClient
# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class Courier:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : typing.Optional[str]
        The base url to use for requests from the client.

    environment : CourierEnvironment
        The environment to use for requests from the client. from .environment import CourierEnvironment



        Defaults to CourierEnvironment.PRODUCTION



    authorization_token : typing.Optional[typing.Union[str, typing.Callable[[], str]]]
    headers : typing.Optional[typing.Dict[str, str]]
        Additional headers to send with every request.

    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests. By default the timeout is 60 seconds, unless a custom httpx client is used, in which case this default is not enforced.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.Client]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from courier import Courier

    client = Courier(
        authorization_token="YOUR_AUTHORIZATION_TOKEN",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: CourierEnvironment = CourierEnvironment.PRODUCTION,
        authorization_token: typing.Optional[typing.Union[str, typing.Callable[[], str]]] = os.getenv(
            "COURIER_AUTH_TOKEN"
        ),
        headers: typing.Optional[typing.Dict[str, str]] = None,
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.Client] = None,
    ):
        _defaulted_timeout = (
            timeout if timeout is not None else 60 if httpx_client is None else httpx_client.timeout.read
        )
        if authorization_token is None:
            raise ApiError(
                body="The client must be instantiated be either passing in authorization_token or setting COURIER_AUTH_TOKEN"
            )
        self._client_wrapper = SyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            authorization_token=authorization_token,
            headers=headers,
            httpx_client=httpx_client
            if httpx_client is not None
            else httpx.Client(timeout=_defaulted_timeout, follow_redirects=follow_redirects)
            if follow_redirects is not None
            else httpx.Client(timeout=_defaulted_timeout),
            timeout=_defaulted_timeout,
        )
        self._raw_client = RawCourier(client_wrapper=self._client_wrapper)
        self._audiences: typing.Optional[AudiencesClient] = None
        self._audit_events: typing.Optional[AuditEventsClient] = None
        self._auth_tokens: typing.Optional[AuthTokensClient] = None
        self._automations: typing.Optional[AutomationsClient] = None
        self._brands: typing.Optional[BrandsClient] = None
        self._bulk: typing.Optional[BulkClient] = None
        self._inbound: typing.Optional[InboundClient] = None
        self._lists: typing.Optional[ListsClient] = None
        self._messages: typing.Optional[MessagesClient] = None
        self._notifications: typing.Optional[NotificationsClient] = None
        self._profiles: typing.Optional[ProfilesClient] = None
        self._templates: typing.Optional[TemplatesClient] = None
        self._tenants: typing.Optional[TenantsClient] = None
        self._translations: typing.Optional[TranslationsClient] = None
        self._users: typing.Optional[UsersClient] = None

    @property
    def with_raw_response(self) -> RawCourier:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawCourier
        """
        return self._raw_client

    def send(
        self,
        *,
        message: Message,
        idempotency_key: typing.Optional[str] = None,
        idempotency_expiry: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SendMessageResponse:
        """
        Use the send API to send a message to one or more recipients.

        Parameters
        ----------
        message : Message
            Defines the message to be delivered

        idempotency_key : typing.Optional[str]

        idempotency_expiry : typing.Optional[str]
            The expiry can either be an ISO8601 datetime or a duration like "1 Day".

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SendMessageResponse

        Examples
        --------
        from courier import Courier
        from courier.send import (
            ContentMessage,
            ElementalContentSugar,
            Routing,
            UserRecipient,
        )

        client = Courier(
            authorization_token="YOUR_AUTHORIZATION_TOKEN",
        )
        client.send(
            message=ContentMessage(
                to=UserRecipient(
                    email="email@example.com",
                ),
                content=ElementalContentSugar(
                    title="Welcome!",
                    body="Thanks for signing up, {{name}}",
                ),
                data={"name": "Peter Parker"},
                routing=Routing(
                    method="single",
                    channels=["email"],
                ),
            ),
        )
        """
        _response = self._raw_client.send(
            message=message,
            idempotency_key=idempotency_key,
            idempotency_expiry=idempotency_expiry,
            request_options=request_options,
        )
        return _response.data

    @property
    def audiences(self):
        if self._audiences is None:
            from .audiences.client import AudiencesClient  # noqa: E402

            self._audiences = AudiencesClient(client_wrapper=self._client_wrapper)
        return self._audiences

    @property
    def audit_events(self):
        if self._audit_events is None:
            from .audit_events.client import AuditEventsClient  # noqa: E402

            self._audit_events = AuditEventsClient(client_wrapper=self._client_wrapper)
        return self._audit_events

    @property
    def auth_tokens(self):
        if self._auth_tokens is None:
            from .auth_tokens.client import AuthTokensClient  # noqa: E402

            self._auth_tokens = AuthTokensClient(client_wrapper=self._client_wrapper)
        return self._auth_tokens

    @property
    def automations(self):
        if self._automations is None:
            from .automations.client import AutomationsClient  # noqa: E402

            self._automations = AutomationsClient(client_wrapper=self._client_wrapper)
        return self._automations

    @property
    def brands(self):
        if self._brands is None:
            from .brands.client import BrandsClient  # noqa: E402

            self._brands = BrandsClient(client_wrapper=self._client_wrapper)
        return self._brands

    @property
    def bulk(self):
        if self._bulk is None:
            from .bulk.client import BulkClient  # noqa: E402

            self._bulk = BulkClient(client_wrapper=self._client_wrapper)
        return self._bulk

    @property
    def inbound(self):
        if self._inbound is None:
            from .inbound.client import InboundClient  # noqa: E402

            self._inbound = InboundClient(client_wrapper=self._client_wrapper)
        return self._inbound

    @property
    def lists(self):
        if self._lists is None:
            from .lists.client import ListsClient  # noqa: E402

            self._lists = ListsClient(client_wrapper=self._client_wrapper)
        return self._lists

    @property
    def messages(self):
        if self._messages is None:
            from .messages.client import MessagesClient  # noqa: E402

            self._messages = MessagesClient(client_wrapper=self._client_wrapper)
        return self._messages

    @property
    def notifications(self):
        if self._notifications is None:
            from .notifications.client import NotificationsClient  # noqa: E402

            self._notifications = NotificationsClient(client_wrapper=self._client_wrapper)
        return self._notifications

    @property
    def profiles(self):
        if self._profiles is None:
            from .profiles.client import ProfilesClient  # noqa: E402

            self._profiles = ProfilesClient(client_wrapper=self._client_wrapper)
        return self._profiles

    @property
    def templates(self):
        if self._templates is None:
            from .templates.client import TemplatesClient  # noqa: E402

            self._templates = TemplatesClient(client_wrapper=self._client_wrapper)
        return self._templates

    @property
    def tenants(self):
        if self._tenants is None:
            from .tenants.client import TenantsClient  # noqa: E402

            self._tenants = TenantsClient(client_wrapper=self._client_wrapper)
        return self._tenants

    @property
    def translations(self):
        if self._translations is None:
            from .translations.client import TranslationsClient  # noqa: E402

            self._translations = TranslationsClient(client_wrapper=self._client_wrapper)
        return self._translations

    @property
    def users(self):
        if self._users is None:
            from .users.client import UsersClient  # noqa: E402

            self._users = UsersClient(client_wrapper=self._client_wrapper)
        return self._users


class AsyncCourier:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : typing.Optional[str]
        The base url to use for requests from the client.

    environment : CourierEnvironment
        The environment to use for requests from the client. from .environment import CourierEnvironment



        Defaults to CourierEnvironment.PRODUCTION



    authorization_token : typing.Optional[typing.Union[str, typing.Callable[[], str]]]
    headers : typing.Optional[typing.Dict[str, str]]
        Additional headers to send with every request.

    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests. By default the timeout is 60 seconds, unless a custom httpx client is used, in which case this default is not enforced.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.AsyncClient]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from courier import AsyncCourier

    client = AsyncCourier(
        authorization_token="YOUR_AUTHORIZATION_TOKEN",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: CourierEnvironment = CourierEnvironment.PRODUCTION,
        authorization_token: typing.Optional[typing.Union[str, typing.Callable[[], str]]] = os.getenv(
            "COURIER_AUTH_TOKEN"
        ),
        headers: typing.Optional[typing.Dict[str, str]] = None,
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.AsyncClient] = None,
    ):
        _defaulted_timeout = (
            timeout if timeout is not None else 60 if httpx_client is None else httpx_client.timeout.read
        )
        if authorization_token is None:
            raise ApiError(
                body="The client must be instantiated be either passing in authorization_token or setting COURIER_AUTH_TOKEN"
            )
        self._client_wrapper = AsyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            authorization_token=authorization_token,
            headers=headers,
            httpx_client=httpx_client
            if httpx_client is not None
            else httpx.AsyncClient(timeout=_defaulted_timeout, follow_redirects=follow_redirects)
            if follow_redirects is not None
            else httpx.AsyncClient(timeout=_defaulted_timeout),
            timeout=_defaulted_timeout,
        )
        self._raw_client = AsyncRawCourier(client_wrapper=self._client_wrapper)
        self._audiences: typing.Optional[AsyncAudiencesClient] = None
        self._audit_events: typing.Optional[AsyncAuditEventsClient] = None
        self._auth_tokens: typing.Optional[AsyncAuthTokensClient] = None
        self._automations: typing.Optional[AsyncAutomationsClient] = None
        self._brands: typing.Optional[AsyncBrandsClient] = None
        self._bulk: typing.Optional[AsyncBulkClient] = None
        self._inbound: typing.Optional[AsyncInboundClient] = None
        self._lists: typing.Optional[AsyncListsClient] = None
        self._messages: typing.Optional[AsyncMessagesClient] = None
        self._notifications: typing.Optional[AsyncNotificationsClient] = None
        self._profiles: typing.Optional[AsyncProfilesClient] = None
        self._templates: typing.Optional[AsyncTemplatesClient] = None
        self._tenants: typing.Optional[AsyncTenantsClient] = None
        self._translations: typing.Optional[AsyncTranslationsClient] = None
        self._users: typing.Optional[AsyncUsersClient] = None

    @property
    def with_raw_response(self) -> AsyncRawCourier:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawCourier
        """
        return self._raw_client

    async def send(
        self,
        *,
        message: Message,
        idempotency_key: typing.Optional[str] = None,
        idempotency_expiry: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SendMessageResponse:
        """
        Use the send API to send a message to one or more recipients.

        Parameters
        ----------
        message : Message
            Defines the message to be delivered

        idempotency_key : typing.Optional[str]

        idempotency_expiry : typing.Optional[str]
            The expiry can either be an ISO8601 datetime or a duration like "1 Day".

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SendMessageResponse

        Examples
        --------
        import asyncio

        from courier import AsyncCourier
        from courier.send import (
            ContentMessage,
            ElementalContentSugar,
            Routing,
            UserRecipient,
        )

        client = AsyncCourier(
            authorization_token="YOUR_AUTHORIZATION_TOKEN",
        )


        async def main() -> None:
            await client.send(
                message=ContentMessage(
                    to=UserRecipient(
                        email="email@example.com",
                    ),
                    content=ElementalContentSugar(
                        title="Welcome!",
                        body="Thanks for signing up, {{name}}",
                    ),
                    data={"name": "Peter Parker"},
                    routing=Routing(
                        method="single",
                        channels=["email"],
                    ),
                ),
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.send(
            message=message,
            idempotency_key=idempotency_key,
            idempotency_expiry=idempotency_expiry,
            request_options=request_options,
        )
        return _response.data

    @property
    def audiences(self):
        if self._audiences is None:
            from .audiences.client import AsyncAudiencesClient  # noqa: E402

            self._audiences = AsyncAudiencesClient(client_wrapper=self._client_wrapper)
        return self._audiences

    @property
    def audit_events(self):
        if self._audit_events is None:
            from .audit_events.client import AsyncAuditEventsClient  # noqa: E402

            self._audit_events = AsyncAuditEventsClient(client_wrapper=self._client_wrapper)
        return self._audit_events

    @property
    def auth_tokens(self):
        if self._auth_tokens is None:
            from .auth_tokens.client import AsyncAuthTokensClient  # noqa: E402

            self._auth_tokens = AsyncAuthTokensClient(client_wrapper=self._client_wrapper)
        return self._auth_tokens

    @property
    def automations(self):
        if self._automations is None:
            from .automations.client import AsyncAutomationsClient  # noqa: E402

            self._automations = AsyncAutomationsClient(client_wrapper=self._client_wrapper)
        return self._automations

    @property
    def brands(self):
        if self._brands is None:
            from .brands.client import AsyncBrandsClient  # noqa: E402

            self._brands = AsyncBrandsClient(client_wrapper=self._client_wrapper)
        return self._brands

    @property
    def bulk(self):
        if self._bulk is None:
            from .bulk.client import AsyncBulkClient  # noqa: E402

            self._bulk = AsyncBulkClient(client_wrapper=self._client_wrapper)
        return self._bulk

    @property
    def inbound(self):
        if self._inbound is None:
            from .inbound.client import AsyncInboundClient  # noqa: E402

            self._inbound = AsyncInboundClient(client_wrapper=self._client_wrapper)
        return self._inbound

    @property
    def lists(self):
        if self._lists is None:
            from .lists.client import AsyncListsClient  # noqa: E402

            self._lists = AsyncListsClient(client_wrapper=self._client_wrapper)
        return self._lists

    @property
    def messages(self):
        if self._messages is None:
            from .messages.client import AsyncMessagesClient  # noqa: E402

            self._messages = AsyncMessagesClient(client_wrapper=self._client_wrapper)
        return self._messages

    @property
    def notifications(self):
        if self._notifications is None:
            from .notifications.client import AsyncNotificationsClient  # noqa: E402

            self._notifications = AsyncNotificationsClient(client_wrapper=self._client_wrapper)
        return self._notifications

    @property
    def profiles(self):
        if self._profiles is None:
            from .profiles.client import AsyncProfilesClient  # noqa: E402

            self._profiles = AsyncProfilesClient(client_wrapper=self._client_wrapper)
        return self._profiles

    @property
    def templates(self):
        if self._templates is None:
            from .templates.client import AsyncTemplatesClient  # noqa: E402

            self._templates = AsyncTemplatesClient(client_wrapper=self._client_wrapper)
        return self._templates

    @property
    def tenants(self):
        if self._tenants is None:
            from .tenants.client import AsyncTenantsClient  # noqa: E402

            self._tenants = AsyncTenantsClient(client_wrapper=self._client_wrapper)
        return self._tenants

    @property
    def translations(self):
        if self._translations is None:
            from .translations.client import AsyncTranslationsClient  # noqa: E402

            self._translations = AsyncTranslationsClient(client_wrapper=self._client_wrapper)
        return self._translations

    @property
    def users(self):
        if self._users is None:
            from .users.client import AsyncUsersClient  # noqa: E402

            self._users = AsyncUsersClient(client_wrapper=self._client_wrapper)
        return self._users


def _get_base_url(*, base_url: typing.Optional[str] = None, environment: CourierEnvironment) -> str:
    if base_url is not None:
        return base_url
    elif environment is not None:
        return environment.value
    else:
        raise Exception("Please pass in either base_url or environment to construct the client")
