# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ..commons.errors.bad_request_error import BadRequestError
from ..commons.errors.not_found_error import NotFoundError
from ..commons.types.bad_request import BadRequest
from ..commons.types.not_found import NotFound
from ..commons.types.recipient_preferences import RecipientPreferences
from .types.list import List
from .types.list_get_all_response import ListGetAllResponse
from .types.list_get_subscriptions_response import ListGetSubscriptionsResponse
from .types.list_put_params import ListPutParams
from .types.put_subscriptions_recipient import PutSubscriptionsRecipient

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ListsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(self, *, cursor: typing.Optional[str] = None, pattern: typing.Optional[str] = None) -> ListGetAllResponse:
        """
        Returns all of the lists, with the ability to filter based on a pattern.

        Parameters:
            - cursor: typing.Optional[str]. A unique identifier that allows for fetching the next page of lists.

            - pattern: typing.Optional[str]. "A pattern used to filter the list items returned. Pattern types supported: exact match on `list_id` or a pattern of one or more pattern parts. you may replace a part with either: `*` to match all parts in that position, or `**` to signify a wildcard `endsWith` pattern match."
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "lists"),
            params=remove_none_from_dict({"cursor": cursor, "pattern": pattern}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ListGetAllResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequest, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, list_id: str, *, cursor: typing.Optional[str] = None, pattern: typing.Optional[str] = None) -> List:
        """
        Returns a list based on the list ID provided.

        Parameters:
            - list_id: str. A unique identifier representing the list you wish to retrieve.

            - cursor: typing.Optional[str]. A unique identifier that allows for fetching the next page of lists.

            - pattern: typing.Optional[str]. "A pattern used to filter the list items returned. Pattern types supported: exact match on `list_id` or a pattern of one or more pattern parts. you may replace a part with either: `*` to match all parts in that position, or `**` to signify a wildcard `endsWith` pattern match."
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"lists/{list_id}"),
            params=remove_none_from_dict({"cursor": cursor, "pattern": pattern}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(List, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(NotFound, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(self, list_id: str, *, request: ListPutParams) -> List:
        """
        Create or replace an existing list with the supplied values.

        Parameters:
            - list_id: str. A unique identifier representing the list you wish to retrieve.

            - request: ListPutParams.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"lists/{list_id}"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(List, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, list_id: str) -> None:
        """
        Delete a list by list ID.

        Parameters:
            - list_id: str. A unique identifier representing the list you wish to retrieve.
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"lists/{list_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def restore(self, list_id: str) -> None:
        """
        Restore a previously deleted list.

        Parameters:
            - list_id: str. A unique identifier representing the list you wish to retrieve.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"lists/{list_id}/restore"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_subscribers(self, list_id: str, *, cursor: typing.Optional[str] = None) -> ListGetSubscriptionsResponse:
        """
        Get the list's subscriptions.

        Parameters:
            - list_id: str. A unique identifier representing the list you wish to retrieve.

            - cursor: typing.Optional[str]. A unique identifier that allows for fetching the next set of list subscriptions
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"lists/{list_id}/subscriptions"),
            params=remove_none_from_dict({"cursor": cursor}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ListGetSubscriptionsResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(NotFound, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_subscribers(self, list_id: str, *, request: typing.List[PutSubscriptionsRecipient]) -> None:
        """
        Subscribes the users to the list, overwriting existing subscriptions. If the list does not exist, it will be automatically created.

        Parameters:
            - list_id: str. A unique identifier representing the list you wish to retrieve.

            - request: typing.List[PutSubscriptionsRecipient].
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"lists/{list_id}/subscriptions"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequest, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def add_subscribers(
        self,
        list_id: str,
        *,
        request: typing.List[PutSubscriptionsRecipient],
        idempotency_key: typing.Optional[str] = None,
        idempotency_expiry: typing.Optional[int] = None,
    ) -> None:
        """
        Subscribes additional users to the list, without modifying existing subscriptions. If the list does not exist, it will be automatically created.

        Parameters:
            - list_id: str. A unique identifier representing the list you wish to retrieve.

            - request: typing.List[PutSubscriptionsRecipient].

            - idempotency_key: typing.Optional[str].

            - idempotency_expiry: typing.Optional[int].
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"lists/{list_id}/subscriptions"),
            json=jsonable_encoder(request),
            headers=remove_none_from_dict(
                {
                    **self._client_wrapper.get_headers(),
                    "Idempotency-Key": idempotency_key,
                    "X-Idempotency-Expiration": idempotency_expiry,
                }
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequest, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def subscribe(
        self, list_id: str, user_id: str, *, preferences: typing.Optional[RecipientPreferences] = OMIT
    ) -> None:
        """
        Subscribe a user to an existing list (note: if the List does not exist, it will be automatically created).

        Parameters:
            - list_id: str. A unique identifier representing the list you wish to retrieve.

            - user_id: str. A unique identifier representing the recipient associated with the list

            - preferences: typing.Optional[RecipientPreferences].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if preferences is not OMIT:
            _request["preferences"] = preferences
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"lists/{list_id}/subscriptions/{user_id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def unsubscribe(self, list_id: str, user_id: str) -> None:
        """
        Delete a subscription to a list by list ID and user ID.

        Parameters:
            - list_id: str. A unique identifier representing the list you wish to retrieve.

            - user_id: str. A unique identifier representing the recipient associated with the list
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"lists/{list_id}/subscriptions/{user_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(NotFound, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncListsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self, *, cursor: typing.Optional[str] = None, pattern: typing.Optional[str] = None
    ) -> ListGetAllResponse:
        """
        Returns all of the lists, with the ability to filter based on a pattern.

        Parameters:
            - cursor: typing.Optional[str]. A unique identifier that allows for fetching the next page of lists.

            - pattern: typing.Optional[str]. "A pattern used to filter the list items returned. Pattern types supported: exact match on `list_id` or a pattern of one or more pattern parts. you may replace a part with either: `*` to match all parts in that position, or `**` to signify a wildcard `endsWith` pattern match."
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "lists"),
            params=remove_none_from_dict({"cursor": cursor, "pattern": pattern}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ListGetAllResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequest, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self, list_id: str, *, cursor: typing.Optional[str] = None, pattern: typing.Optional[str] = None
    ) -> List:
        """
        Returns a list based on the list ID provided.

        Parameters:
            - list_id: str. A unique identifier representing the list you wish to retrieve.

            - cursor: typing.Optional[str]. A unique identifier that allows for fetching the next page of lists.

            - pattern: typing.Optional[str]. "A pattern used to filter the list items returned. Pattern types supported: exact match on `list_id` or a pattern of one or more pattern parts. you may replace a part with either: `*` to match all parts in that position, or `**` to signify a wildcard `endsWith` pattern match."
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"lists/{list_id}"),
            params=remove_none_from_dict({"cursor": cursor, "pattern": pattern}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(List, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(NotFound, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(self, list_id: str, *, request: ListPutParams) -> List:
        """
        Create or replace an existing list with the supplied values.

        Parameters:
            - list_id: str. A unique identifier representing the list you wish to retrieve.

            - request: ListPutParams.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"lists/{list_id}"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(List, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(self, list_id: str) -> None:
        """
        Delete a list by list ID.

        Parameters:
            - list_id: str. A unique identifier representing the list you wish to retrieve.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"lists/{list_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def restore(self, list_id: str) -> None:
        """
        Restore a previously deleted list.

        Parameters:
            - list_id: str. A unique identifier representing the list you wish to retrieve.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"lists/{list_id}/restore"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_subscribers(
        self, list_id: str, *, cursor: typing.Optional[str] = None
    ) -> ListGetSubscriptionsResponse:
        """
        Get the list's subscriptions.

        Parameters:
            - list_id: str. A unique identifier representing the list you wish to retrieve.

            - cursor: typing.Optional[str]. A unique identifier that allows for fetching the next set of list subscriptions
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"lists/{list_id}/subscriptions"),
            params=remove_none_from_dict({"cursor": cursor}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ListGetSubscriptionsResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(NotFound, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_subscribers(self, list_id: str, *, request: typing.List[PutSubscriptionsRecipient]) -> None:
        """
        Subscribes the users to the list, overwriting existing subscriptions. If the list does not exist, it will be automatically created.

        Parameters:
            - list_id: str. A unique identifier representing the list you wish to retrieve.

            - request: typing.List[PutSubscriptionsRecipient].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"lists/{list_id}/subscriptions"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequest, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def add_subscribers(
        self,
        list_id: str,
        *,
        request: typing.List[PutSubscriptionsRecipient],
        idempotency_key: typing.Optional[str] = None,
        idempotency_expiry: typing.Optional[int] = None,
    ) -> None:
        """
        Subscribes additional users to the list, without modifying existing subscriptions. If the list does not exist, it will be automatically created.

        Parameters:
            - list_id: str. A unique identifier representing the list you wish to retrieve.

            - request: typing.List[PutSubscriptionsRecipient].

            - idempotency_key: typing.Optional[str].

            - idempotency_expiry: typing.Optional[int].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"lists/{list_id}/subscriptions"),
            json=jsonable_encoder(request),
            headers=remove_none_from_dict(
                {
                    **self._client_wrapper.get_headers(),
                    "Idempotency-Key": idempotency_key,
                    "X-Idempotency-Expiration": idempotency_expiry,
                }
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequest, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def subscribe(
        self, list_id: str, user_id: str, *, preferences: typing.Optional[RecipientPreferences] = OMIT
    ) -> None:
        """
        Subscribe a user to an existing list (note: if the List does not exist, it will be automatically created).

        Parameters:
            - list_id: str. A unique identifier representing the list you wish to retrieve.

            - user_id: str. A unique identifier representing the recipient associated with the list

            - preferences: typing.Optional[RecipientPreferences].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if preferences is not OMIT:
            _request["preferences"] = preferences
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"lists/{list_id}/subscriptions/{user_id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def unsubscribe(self, list_id: str, user_id: str) -> None:
        """
        Delete a subscription to a list by list ID and user ID.

        Parameters:
            - list_id: str. A unique identifier representing the list you wish to retrieve.

            - user_id: str. A unique identifier representing the recipient associated with the list
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"lists/{list_id}/subscriptions/{user_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(NotFound, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
