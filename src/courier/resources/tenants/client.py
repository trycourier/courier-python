# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ..commons.errors.bad_request_error import BadRequestError
from ..commons.types.bad_request import BadRequest
from .types.default_preferences import DefaultPreferences
from .types.list_users_for_tenant_response import ListUsersForTenantResponse
from .types.template_property import TemplateProperty
from .types.tenant import Tenant
from .types.tenant_list_response import TenantListResponse

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class TenantsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create_or_replace(
        self,
        tenant_id: str,
        *,
        name: str,
        parent_tenant_id: typing.Optional[str] = OMIT,
        default_preferences: typing.Optional[DefaultPreferences] = OMIT,
        properties: typing.Optional[typing.List[TemplateProperty]] = OMIT,
        user_profile: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        brand_id: typing.Optional[str] = OMIT,
    ) -> Tenant:
        """
        Parameters:
            - tenant_id: str. A unique identifier representing the tenant to be returned.

            - name: str. Name of the tenant.

            - parent_tenant_id: typing.Optional[str]. Tenant's parent id (if any).

            - default_preferences: typing.Optional[DefaultPreferences]. Defines the preferences used for the tenant when the user hasn't specified their own.

            - properties: typing.Optional[typing.List[TemplateProperty]]. Arbitrary properties accessible to a template.

            - user_profile: typing.Optional[typing.Dict[str, typing.Any]]. A user profile object merged with user profile on send.

            - brand_id: typing.Optional[str]. Brand to be used for the account when one is not specified by the send call.
        """
        _request: typing.Dict[str, typing.Any] = {"name": name}
        if parent_tenant_id is not OMIT:
            _request["parent_tenant_id"] = parent_tenant_id
        if default_preferences is not OMIT:
            _request["default_preferences"] = default_preferences
        if properties is not OMIT:
            _request["properties"] = properties
        if user_profile is not OMIT:
            _request["user_profile"] = user_profile
        if brand_id is not OMIT:
            _request["brand_id"] = brand_id
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"tenants/{tenant_id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Tenant, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequest, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, tenant_id: str) -> Tenant:
        """
        Parameters:
            - tenant_id: str. A unique identifier representing the tenant to be returned.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"tenants/{tenant_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Tenant, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequest, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list(self) -> TenantListResponse:
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "tenants"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TenantListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, tenant_id: str) -> None:
        """
        Parameters:
            - tenant_id: str. Id of the tenant to be deleted.
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"tenants/{tenant_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_users_by_tenant(self, tenant_id: str) -> ListUsersForTenantResponse:
        """
        Parameters:
            - tenant_id: str. Id of the tenant for user membership.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"tenants/{tenant_id}/users"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ListUsersForTenantResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequest, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncTenantsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create_or_replace(
        self,
        tenant_id: str,
        *,
        name: str,
        parent_tenant_id: typing.Optional[str] = OMIT,
        default_preferences: typing.Optional[DefaultPreferences] = OMIT,
        properties: typing.Optional[typing.List[TemplateProperty]] = OMIT,
        user_profile: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        brand_id: typing.Optional[str] = OMIT,
    ) -> Tenant:
        """
        Parameters:
            - tenant_id: str. A unique identifier representing the tenant to be returned.

            - name: str. Name of the tenant.

            - parent_tenant_id: typing.Optional[str]. Tenant's parent id (if any).

            - default_preferences: typing.Optional[DefaultPreferences]. Defines the preferences used for the tenant when the user hasn't specified their own.

            - properties: typing.Optional[typing.List[TemplateProperty]]. Arbitrary properties accessible to a template.

            - user_profile: typing.Optional[typing.Dict[str, typing.Any]]. A user profile object merged with user profile on send.

            - brand_id: typing.Optional[str]. Brand to be used for the account when one is not specified by the send call.
        """
        _request: typing.Dict[str, typing.Any] = {"name": name}
        if parent_tenant_id is not OMIT:
            _request["parent_tenant_id"] = parent_tenant_id
        if default_preferences is not OMIT:
            _request["default_preferences"] = default_preferences
        if properties is not OMIT:
            _request["properties"] = properties
        if user_profile is not OMIT:
            _request["user_profile"] = user_profile
        if brand_id is not OMIT:
            _request["brand_id"] = brand_id
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"tenants/{tenant_id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Tenant, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequest, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(self, tenant_id: str) -> Tenant:
        """
        Parameters:
            - tenant_id: str. A unique identifier representing the tenant to be returned.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"tenants/{tenant_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Tenant, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequest, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list(self) -> TenantListResponse:
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "tenants"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TenantListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(self, tenant_id: str) -> None:
        """
        Parameters:
            - tenant_id: str. Id of the tenant to be deleted.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"tenants/{tenant_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_users_by_tenant(self, tenant_id: str) -> ListUsersForTenantResponse:
        """
        Parameters:
            - tenant_id: str. Id of the tenant for user membership.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"tenants/{tenant_id}/users"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ListUsersForTenantResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequest, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
