# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..commons.errors.bad_request_error import BadRequestError
from ..commons.types.bad_request import BadRequest
from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from .types.default_preferences import DefaultPreferences
from .types.get_template_by_tenant_response import GetTemplateByTenantResponse
from .types.list_templates_by_tenant_response import ListTemplatesByTenantResponse
from .types.list_users_for_tenant_response import ListUsersForTenantResponse
from .types.subscription_topic_new import SubscriptionTopicNew
from .types.tenant import Tenant
from .types.tenant_list_response import TenantListResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawTenantsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create_or_replace(
        self,
        tenant_id: str,
        *,
        name: str,
        parent_tenant_id: typing.Optional[str] = OMIT,
        default_preferences: typing.Optional[DefaultPreferences] = OMIT,
        properties: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        user_profile: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        brand_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Tenant]:
        """
        Parameters
        ----------
        tenant_id : str
            A unique identifier representing the tenant to be returned.

        name : str
            Name of the tenant.

        parent_tenant_id : typing.Optional[str]
            Tenant's parent id (if any).

        default_preferences : typing.Optional[DefaultPreferences]
            Defines the preferences used for the tenant when the user hasn't specified their own.

        properties : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Arbitrary properties accessible to a template.

        user_profile : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            A user profile object merged with user profile on send.

        brand_id : typing.Optional[str]
            Brand to be used for the account when one is not specified by the send call.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Tenant]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tenants/{jsonable_encoder(tenant_id)}",
            method="PUT",
            json={
                "name": name,
                "parent_tenant_id": parent_tenant_id,
                "default_preferences": convert_and_respect_annotation_metadata(
                    object_=default_preferences, annotation=DefaultPreferences, direction="write"
                ),
                "properties": properties,
                "user_profile": user_profile,
                "brand_id": brand_id,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Tenant,
                    construct_type(
                        type_=Tenant,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BadRequest,
                        construct_type(
                            type_=BadRequest,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get(self, tenant_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[Tenant]:
        """
        Parameters
        ----------
        tenant_id : str
            A unique identifier representing the tenant to be returned.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Tenant]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tenants/{jsonable_encoder(tenant_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Tenant,
                    construct_type(
                        type_=Tenant,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BadRequest,
                        construct_type(
                            type_=BadRequest,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list(
        self,
        *,
        parent_tenant_id: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        cursor: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TenantListResponse]:
        """
        Parameters
        ----------
        parent_tenant_id : typing.Optional[str]
            Filter the list of tenants by parent_id

        limit : typing.Optional[int]
            The number of tenants to return
            (defaults to 20, maximum value of 100)

        cursor : typing.Optional[str]
            Continue the pagination with the next cursor

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TenantListResponse]
        """
        _response = self._client_wrapper.httpx_client.request(
            "tenants",
            method="GET",
            params={
                "parent_tenant_id": parent_tenant_id,
                "limit": limit,
                "cursor": cursor,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TenantListResponse,
                    construct_type(
                        type_=TenantListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(self, tenant_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[None]:
        """
        Parameters
        ----------
        tenant_id : str
            Id of the tenant to be deleted.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tenants/{jsonable_encoder(tenant_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_users_by_tenant(
        self,
        tenant_id: str,
        *,
        limit: typing.Optional[int] = None,
        cursor: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListUsersForTenantResponse]:
        """
        Parameters
        ----------
        tenant_id : str
            Id of the tenant for user membership.

        limit : typing.Optional[int]
            The number of accounts to return
            (defaults to 20, maximum value of 100)

        cursor : typing.Optional[str]
            Continue the pagination with the next cursor

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListUsersForTenantResponse]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tenants/{jsonable_encoder(tenant_id)}/users",
            method="GET",
            params={
                "limit": limit,
                "cursor": cursor,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListUsersForTenantResponse,
                    construct_type(
                        type_=ListUsersForTenantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BadRequest,
                        construct_type(
                            type_=BadRequest,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_or_replace_default_preferences_for_topic(
        self,
        tenant_id: str,
        topic_id: str,
        *,
        request: SubscriptionTopicNew,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        tenant_id : str
            Id of the tenant to update the default preferences for.

        topic_id : str
            Id fo the susbcription topic you want to have a default preference for.

        request : SubscriptionTopicNew

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tenants/{jsonable_encoder(tenant_id)}/default_preferences/items/{jsonable_encoder(topic_id)}",
            method="PUT",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=SubscriptionTopicNew, direction="write"
            ),
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def remove_default_preferences_for_topic(
        self, tenant_id: str, topic_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        tenant_id : str
            Id of the tenant to update the default preferences for.

        topic_id : str
            Id fo the susbcription topic you want to have a default preference for.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tenants/{jsonable_encoder(tenant_id)}/default_preferences/items/{jsonable_encoder(topic_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_template_by_tenant(
        self, tenant_id: str, template_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetTemplateByTenantResponse]:
        """
        Parameters
        ----------
        tenant_id : str
            Id of the tenant for which to retrieve the template.

        template_id : str
            Id of the template to be retrieved.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetTemplateByTenantResponse]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tenants/{jsonable_encoder(tenant_id)}/templates/{jsonable_encoder(template_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetTemplateByTenantResponse,
                    construct_type(
                        type_=GetTemplateByTenantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BadRequest,
                        construct_type(
                            type_=BadRequest,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_template_list_by_tenant(
        self,
        tenant_id: str,
        *,
        limit: typing.Optional[int] = None,
        cursor: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListTemplatesByTenantResponse]:
        """
        Parameters
        ----------
        tenant_id : str
            Id of the tenant for which to retrieve the templates.

        limit : typing.Optional[int]
            The number of templates to return (defaults to 20, maximum value of 100)

        cursor : typing.Optional[str]
            Continue the pagination with the next cursor

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListTemplatesByTenantResponse]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tenants/{jsonable_encoder(tenant_id)}/templates",
            method="GET",
            params={
                "limit": limit,
                "cursor": cursor,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListTemplatesByTenantResponse,
                    construct_type(
                        type_=ListTemplatesByTenantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BadRequest,
                        construct_type(
                            type_=BadRequest,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawTenantsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create_or_replace(
        self,
        tenant_id: str,
        *,
        name: str,
        parent_tenant_id: typing.Optional[str] = OMIT,
        default_preferences: typing.Optional[DefaultPreferences] = OMIT,
        properties: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        user_profile: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        brand_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Tenant]:
        """
        Parameters
        ----------
        tenant_id : str
            A unique identifier representing the tenant to be returned.

        name : str
            Name of the tenant.

        parent_tenant_id : typing.Optional[str]
            Tenant's parent id (if any).

        default_preferences : typing.Optional[DefaultPreferences]
            Defines the preferences used for the tenant when the user hasn't specified their own.

        properties : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Arbitrary properties accessible to a template.

        user_profile : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            A user profile object merged with user profile on send.

        brand_id : typing.Optional[str]
            Brand to be used for the account when one is not specified by the send call.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Tenant]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tenants/{jsonable_encoder(tenant_id)}",
            method="PUT",
            json={
                "name": name,
                "parent_tenant_id": parent_tenant_id,
                "default_preferences": convert_and_respect_annotation_metadata(
                    object_=default_preferences, annotation=DefaultPreferences, direction="write"
                ),
                "properties": properties,
                "user_profile": user_profile,
                "brand_id": brand_id,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Tenant,
                    construct_type(
                        type_=Tenant,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BadRequest,
                        construct_type(
                            type_=BadRequest,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get(
        self, tenant_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[Tenant]:
        """
        Parameters
        ----------
        tenant_id : str
            A unique identifier representing the tenant to be returned.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Tenant]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tenants/{jsonable_encoder(tenant_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Tenant,
                    construct_type(
                        type_=Tenant,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BadRequest,
                        construct_type(
                            type_=BadRequest,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list(
        self,
        *,
        parent_tenant_id: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        cursor: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TenantListResponse]:
        """
        Parameters
        ----------
        parent_tenant_id : typing.Optional[str]
            Filter the list of tenants by parent_id

        limit : typing.Optional[int]
            The number of tenants to return
            (defaults to 20, maximum value of 100)

        cursor : typing.Optional[str]
            Continue the pagination with the next cursor

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TenantListResponse]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tenants",
            method="GET",
            params={
                "parent_tenant_id": parent_tenant_id,
                "limit": limit,
                "cursor": cursor,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TenantListResponse,
                    construct_type(
                        type_=TenantListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self, tenant_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        tenant_id : str
            Id of the tenant to be deleted.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tenants/{jsonable_encoder(tenant_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_users_by_tenant(
        self,
        tenant_id: str,
        *,
        limit: typing.Optional[int] = None,
        cursor: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListUsersForTenantResponse]:
        """
        Parameters
        ----------
        tenant_id : str
            Id of the tenant for user membership.

        limit : typing.Optional[int]
            The number of accounts to return
            (defaults to 20, maximum value of 100)

        cursor : typing.Optional[str]
            Continue the pagination with the next cursor

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListUsersForTenantResponse]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tenants/{jsonable_encoder(tenant_id)}/users",
            method="GET",
            params={
                "limit": limit,
                "cursor": cursor,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListUsersForTenantResponse,
                    construct_type(
                        type_=ListUsersForTenantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BadRequest,
                        construct_type(
                            type_=BadRequest,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_or_replace_default_preferences_for_topic(
        self,
        tenant_id: str,
        topic_id: str,
        *,
        request: SubscriptionTopicNew,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        tenant_id : str
            Id of the tenant to update the default preferences for.

        topic_id : str
            Id fo the susbcription topic you want to have a default preference for.

        request : SubscriptionTopicNew

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tenants/{jsonable_encoder(tenant_id)}/default_preferences/items/{jsonable_encoder(topic_id)}",
            method="PUT",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=SubscriptionTopicNew, direction="write"
            ),
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def remove_default_preferences_for_topic(
        self, tenant_id: str, topic_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        tenant_id : str
            Id of the tenant to update the default preferences for.

        topic_id : str
            Id fo the susbcription topic you want to have a default preference for.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tenants/{jsonable_encoder(tenant_id)}/default_preferences/items/{jsonable_encoder(topic_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_template_by_tenant(
        self, tenant_id: str, template_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetTemplateByTenantResponse]:
        """
        Parameters
        ----------
        tenant_id : str
            Id of the tenant for which to retrieve the template.

        template_id : str
            Id of the template to be retrieved.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetTemplateByTenantResponse]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tenants/{jsonable_encoder(tenant_id)}/templates/{jsonable_encoder(template_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetTemplateByTenantResponse,
                    construct_type(
                        type_=GetTemplateByTenantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BadRequest,
                        construct_type(
                            type_=BadRequest,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_template_list_by_tenant(
        self,
        tenant_id: str,
        *,
        limit: typing.Optional[int] = None,
        cursor: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListTemplatesByTenantResponse]:
        """
        Parameters
        ----------
        tenant_id : str
            Id of the tenant for which to retrieve the templates.

        limit : typing.Optional[int]
            The number of templates to return (defaults to 20, maximum value of 100)

        cursor : typing.Optional[str]
            Continue the pagination with the next cursor

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListTemplatesByTenantResponse]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tenants/{jsonable_encoder(tenant_id)}/templates",
            method="GET",
            params={
                "limit": limit,
                "cursor": cursor,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListTemplatesByTenantResponse,
                    construct_type(
                        type_=ListTemplatesByTenantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BadRequest,
                        construct_type(
                            type_=BadRequest,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
